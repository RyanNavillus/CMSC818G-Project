title,abstract
A Relational Theory of Effects and Coeffects,"Graded modal types systems and coeffects are becoming a standard formalism to deal with context-dependent, usage-sensitive computations, especially when combined with computational effects. From a semantical perspective, effectful and coeffectful languages have been studied mostly from a denotational perspective and almost nothing has been done from the point of view of relational reasoning. This gap in the literature is quite surprising, since many cornerstone results on concrete coeffects - such as \emph{non-interference}, \emph{metric preservation}, and \emph{proof irrelevance} - are inherently relational. In this paper, we fill-in this gap by developing a general theory and calculus of program relations for higher-order languages with combined effects and coeffects. The relational calculus built upon the novel notion of a \emph{corelator} (or \emph{comonadic lax extension}) to handle coeffects relationally. Inside such a calculus, we define three notions of effectful and coeffectful program refinement: contextual approximation, logical relations, and applicative similarity. These are the first operationally-based notions of program refinement (and, consequently, equivalence) for languages with combined effects and coeffects appearing in the literature. We show that the axiomatics of a corelator (together with the one of a relator) is precisely what is needed to prove all the aforementioned program refinements to be precongruences, this way obtaining compositional relational reasoning about combined effects and coeffects."
A Formal Foundation for Symbolic Evaluation with Merging,"Reusable symbolic evaluators are a key building block of solver-aided verification and synthesis tools. A reusable evaluator reduces the semantics of all paths in a program to logical constraints, and a client tool uses these constraints to formulate a satisfiability query that is discharged with SAT or SMT solvers. The correctness of the evaluator is critical to the soundness of the tool and the domain properties it aims to guarantee. Yet so far, the trust in these evaluators has been based on an ad-hoc foundation of testing and manual reasoning.This paper presents the first formal framework for reasoning about the behavior of reusable symbolic evaluators. We develop a new symbolic semantics for these evaluators that incorporates state merging. Symbolic evaluators use state merging to avoid path explosion and generate compact encodings. To accommodate a wide range of implementations, our semantics is parameterized by a symbolic factory, which abstracts away the details of merging and creation of symbolic values. The semantics targets a rich language that extends Core Scheme with assumptions and assertions, and thus supports branching, loops, and (first-class) procedures. The semantics is designed to support reusability, by guaranteeing two key properties: legality of the generated symbolic states, and the reducibility of symbolic evaluation to concrete evaluation. Legality makes it simpler for client tools to formulate queries, and reducibility enables testing of client tools on concrete inputs. We use the Lean theorem prover to mechanize our symbolic semantics, prove that it is sound and complete with respect to the concrete semantics, and prove that it guarantees legality and reducibility.To demonstrate the generality of our semantics, we develop Leanette, a reference evaluator written in Lean, and Rosette*, an optimized evaluator written in Racket. We prove Leanette correct with respect to the semantics, and validate Rosette* against Leanette via solver-aided differential testing. To demonstrate the practicality of our approach, we port 16 published verification and synthesis tools from Rosette to Rosette*. Rosette is an existing reusable evaluator that implements the classic merging semantics, adopted from bounded model checking. Rosette* replaces the semantic core of Rosette but keeps its optimized symbolic factory. Our results show that Rosette* matches the performance of Rosette across a wide range of benchmarks, while providing a cleaner interface that simplifies the implementation of client tools."
Concurrent Incorrectness Separation Logic,"Incorrectness separation logic (ISL) was recently introduced as a theory of under-approximate reasoning, with the goal of proving that compositional bug catchers find actual bugs. However, ISL only considers sequential programs. Here, we develop concurrent incorrectness separation logic (CISL), which extends ISL to account for bug catching in concurrent programs. Inspired by the work on Views, we design CISL as a parametric framework, which can be instantiated for a number of bug catching scenarios, including race detection, deadlock detection, and memory safety error detection. For each instance, the CISL meta-theory ensures the soundness of incorrectness reasoning for free, thereby guaranteeing that the bugs detected are true positives.